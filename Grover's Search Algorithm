# ============================================
# Grover's Algorithm Demonstration on Qiskit
# ============================================

import math
import numpy as np
import matplotlib.pyplot as plt

# --- Qiskit imports ---
from qiskit import QuantumCircuit, transpile
from qiskit.circuit.library import GroverOperator, MCMT, ZGate
from qiskit.visualization import plot_histogram, plot_distribution
from qiskit_aer import Aer
from qiskit_aer.noise import NoiseModel

# Qiskit Runtime
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import SamplerV2 as Sampler

# Fake backend for noise simulation
from qiskit_ibm_runtime.fake_provider import FakeKyiv


# ============================================
# Grover Oracle for multiple marked states
# ============================================

def grover_oracle(marked_states):
    """
    Build a Grover oracle circuit for single or multiple marked bitstrings.

    Args:
        marked_states (str or list): marked bitstrings (e.g., "000" or ["000","111"])

    Returns:
        QuantumCircuit: Oracle circuit
    """
    if isinstance(marked_states, str):
        marked_states = [marked_states]

    num_qubits = len(marked_states[0])
    qc = QuantumCircuit(num_qubits)

    for target in marked_states:
        rev = target[::-1]

        # Indices where the state requires a |0> control â†’ implement as open controls using X
        zero_inds = [i for i, bit in enumerate(rev) if bit == "0"]

        qc.x(zero_inds)
        qc.compose(MCMT(ZGate(), num_qubits - 1, 1), inplace=True)
        qc.x(zero_inds)

    return qc


# Example marked states
marked_states = ["000", "100"]
oracle = grover_oracle(marked_states)
oracle.draw(output="mpl", style="iqp")


# ============================================
# Demonstration of MCMT Gate Decomposition
# ============================================

num_controls = 3
num_targets = 1
total_qubits = num_controls + num_targets

qc = QuantumCircuit(total_qubits, name='MCMT_example')
mcmt_gate = MCMT(ZGate(), total_qubits - 1, 1)
qc.append(mcmt_gate, range(total_qubits))

print("Original circuit with MCMT gate:")
print(qc.draw())

print("\nDecomposed:")
print(qc.decompose().draw())


# ============================================
# Build Grover's Operator
# ============================================

grover_op = GroverOperator(oracle)
grover_op.decompose().draw(output="mpl", style="iqp")


# ============================================
# Grover Initialization
# ============================================

def initialize_s(qc, qubits):
    """Apply Hadamards to all qubits."""
    for q in qubits:
        qc.h(q)
    return qc


n = 3
grover_circuit = QuantumCircuit(n, n)
initialize_s(grover_circuit, range(n))

# Number of Grover iterations (example: 1)
for _ in range(1):
    grover_circuit.append(grover_op, range(n))

grover_circuit.measure(range(n), range(n))
display(grover_circuit.draw("mpl"))
plt.show()


# ============================================
# Optimal number of iterations
# ============================================

optimal_num_iterations = math.floor(
    math.pi / (4 * math.asin(math.sqrt(len(marked_states) / 2**n)))
)
print("Optimal number of Grover iterations:", optimal_num_iterations)


# ============================================
# Noisy Simulation using FakeKyiv backend
# ============================================

backend = FakeKyiv()
noise_model = NoiseModel.from_backend(backend)

noisy_sim = Aer.get_backend("aer_simulator")
noisy_sim = noisy_sim.from_backend(backend)

transpiled_noisy = transpile(grover_circuit, noisy_sim)
results_noisy = noisy_sim.run(transpiled_noisy).result()
counts_noisy = results_noisy.get_counts()

plot_histogram(counts_noisy, title="Grover's Algorithm under Noise")


# ============================================
# Running on Real IBM Quantum Hardware
# ============================================

# IMPORTANT: Replace with your own token, but DO NOT commit it to GitHub.
# service = QiskitRuntimeService(channel="ibm_quantum", token="YOUR_API_TOKEN_HERE")

# Uncomment once you set your token locally:
# backend = service.backend("ibm_kyiv")
# sampler = Sampler(mode=backend)
# transpiled_circuit = transpile(grover_circuit, backend, optimization_level=3)
# job = sampler.run([transpiled_circuit])
# counts = job.result()[0].data.c.get_counts()
# plot_histogram(counts)

